<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹 통신과 API 기본 개념</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            margin: 0 auto;
            max-width: 900px;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3 {
            color: #222;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .section {
            margin-bottom: 40px;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .comparison-table th {
            background-color: #f8f8f8;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>웹 통신과 API 기본 개념: RPC, REST, GraphQL</h1>
        <p>웹 애플리케이션, 특히 Django와 같은 백엔드 프레임워크를 이해하기 위해서는 클라이언트와 서버, 또는 서버와 서버 간의 통신 방식(API)을 아는 것이 중요합니다.</p>

        <!-- RPC Section -->
        <section id="rpc-section" class="section">
            <h2>1. RPC (Remote Procedure Call)</h2>
            <p>RPC는 "원격 프로시저 호출"의 약자로, 한 컴퓨터에서 실행 중인 프로그램이 다른 컴퓨터(원격 서버)에 있는 함수나 프로시저를 마치 자신의 것처럼 호출할 수 있게 하는 통신 방식입니다.</p>
            <h3>동작 방식</h3>
            <ol>
                <li><strong>클라이언트</strong>는 원격 함수를 호출하기 위해 파라미터를 담아 <strong>스텁(Stub)</strong>이라는 로컬 함수를 호출합니다.</li>
                <li>스텁은 파라미터를 네트워크를 통해 전송할 수 있는 형태로 변환(마샬링)하여 서버로 보냅니다.</li>
                <li><strong>서버</strong>의 <strong>스켈레톤(Skeleton)</strong>은 요청을 받아 원래의 형태로 복원(언마샬링)하고, 실제 함수를 실행합니다.</li>
                <li>실행 결과를 다시 클라이언트로 반환하면, 클라이언트 스텁이 이를 받아 최종 결과를 반환합니다.</li>
            </ol>
            <p><strong>핵심 아이디어:</strong> 개발자가 네트워크 통신의 복잡함을 신경 쓰지 않고, 마치 로컬 함수를 호출하듯 원격 기능을 사용할 수 있게 하는 것입니다.</p>
            <pre><code>// RPC 예시 (의사 코드)
// 클라이언트는 그저 함수를 호출할 뿐이다.
result = getUserInfo(userId: 123);</code></pre>
        </section>

        <!-- REST Section -->
        <section id="rest-section" class="section">
            <h2>2. REST (Representational State Transfer)</h2>
            <p>REST는 현재 웹 API 설계에서 가장 널리 사용되는 아키텍처 스타일입니다. "자원(Resource)"이라는 개념을 중심으로, 해당 자원의 상태를 HTTP 메서드(GET, POST, PUT, DELETE 등)를 통해 전달합니다.</p>
            <h3>주요 원칙</h3>
            <ul>
                <li><strong>자원(Resource):</strong> 모든 것은 URI(Uniform Resource Identifier)로 식별되는 고유한 자원입니다. (예: <code>/users/123</code>)</li>
                <li><strong>행위(Verb):</strong> HTTP 메서드(<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>)를 사용하여 자원에 대한 행위를 표현합니다.</li>
                <li><strong>표현(Representation):</strong> 자원의 상태는 JSON, XML 등의 형태로 표현되어 전달됩니다.</li>
                <li><strong>무상태(Stateless):</strong> 서버는 클라이언트의 상태를 저장하지 않습니다. 각 요청은 독립적으로 처리됩니다.</li>
            </ul>
            <p><strong>핵심 아이디어:</strong> 자원을 정의하고, HTTP 메서드를 통해 해당 자원을 어떻게 다룰지(조회, 생성, 수정, 삭제)를 명시적으로 표현하는 것입니다.</p>
            <pre><code># RESTful API 예시
GET /users/123     # 사용자 123의 정보를 조회
POST /users        # 새로운 사용자를 생성
DELETE /users/123  # 사용자 123을 삭제</code></pre>
        </section>

        <!-- GraphQL Section -->
        <section id="graphql-section" class="section">
            <h2>3. GraphQL</h2>
            <p>GraphQL은 Facebook에서 개발한 API용 쿼리 언어이자 런타임입니다. 클라이언트가 필요한 데이터의 구조를 직접 정의하여 요청할 수 있다는 점이 가장 큰 특징입니다.</p>
            <h3>주요 특징</h3>
            <ul>
                <li><strong>정확한 데이터만 가져오기:</strong> 클라이언트가 필요한 필드만 명시하여 요청하므로, Over-fetching(불필요한 데이터까지 받는 것)이나 Under-fetching(필요한 데이터를 위해 여러 번 요청하는 것) 문제를 해결합니다.</li>
                <li><strong>단일 엔드포인트:</strong> 보통 <code>/graphql</code>이라는 단일 엔드포인트로 모든 요청을 보냅니다.</li>
                <li><strong>강력한 타입 시스템:</strong> 스키마를 통해 API의 데이터 구조를 정의하므로, 개발 과정에서 오류를 줄일 수 있습니다.</li>
            </ul>
             <p><strong>핵심 아이디어:</strong> 클라이언트가 API의 데이터 구조를 직접 쿼리하여, 원하는 만큼의 정보만 효율적으로 받아오는 것입니다.</p>
            <pre><code># GraphQL 쿼리 예시
query {
  user(id: 123) {
    name
    email
    posts {
      title
    }
  }
}</code></pre>
        </section>

        <!-- Comparison & Django Relation -->
        <section id="comparison-section" class="section">
            <h2>비교 및 Django와의 관계</h2>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>구분</th>
                        <th>RPC</th>
                        <th>REST</th>
                        <th>GraphQL</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>중심 개념</strong></td>
                        <td>함수 호출 (Actions)</td>
                        <td>자원 (Resources)</td>
                        <td>데이터 구조 (Schema/Query)</td>
                    </tr>
                    <tr>
                        <td><strong>엔드포인트</strong></td>
                        <td>함수마다 다름</td>
                        <td>자원마다 여러 개</td>
                        <td>단일 엔드포인트</td>
                    </tr>
                    <tr>
                        <td><strong>데이터 크기</strong></td>
                        <td>서버가 결정</td>
                        <td>서버가 결정 (Over-fetching 가능)</td>
                        <td>클라이언트가 결정</td>
                    </tr>
                </tbody>
            </table>

            <h3>Django와의 관계</h3>
            <p>Django는 웹 프레임워크로서, 클라이언트(주로 웹 브라우저)의 요청에 응답하는 서버를 만드는 데 사용됩니다. 이 과정에서 API 통신 방식이 결정됩니다.</p>
            <ul>
                <li>Django의 기본은 웹 페이지를 렌더링하여 반환하는 것이지만, <strong>Django REST Framework(DRF)</strong>라는 강력한 라이브러리를 통해 손쉽게 RESTful API를 구축할 수 있습니다. 대부분의 현대적인 Django 프로젝트는 DRF를 사용하여 REST API 서버를 만듭니다.</li>
                <li>Django는 Graphene-Django와 같은 라이브러리를 사용하여 GraphQL API 서버로도 동작할 수 있습니다.</li>
                <li>또한, Django 애플리케이션이 다른 마이크로서비스와 통신해야 할 때, RPC 방식(예: gRPC)의 클라이언트나 서버 역할을 수행할 수도 있습니다.</li>
            </ul>
            <p>결론적으로, Django는 특정 통신 방식에 얽매이지 않는 유연한 프레임워크이지만, 웹 개발 생태계의 표준처럼 여겨지는 <strong>REST 아키텍처를 구현하는 데 가장 널리 사용됩니다.</strong></p>
        </section>

    </div>

</body>
</html>
